   1               		.file	"graphs.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	glcd_bar_graph_horizontal
  12               	glcd_bar_graph_horizontal:
  13               	.LFB7:
  14               		.file 1 "glcd/graphs.c"
   1:glcd/graphs.c **** /**
   2:glcd/graphs.c ****    \file graphs.c
   3:glcd/graphs.c ****    \brief Functions relating to graphs. e.g bar graphs etc.
   4:glcd/graphs.c ****    \author Andy Gock
   5:glcd/graphs.c ****  */ 
   6:glcd/graphs.c **** 
   7:glcd/graphs.c **** /*
   8:glcd/graphs.c **** 	Copyright (c) 2012, Andy Gock
   9:glcd/graphs.c **** 
  10:glcd/graphs.c **** 	All rights reserved.
  11:glcd/graphs.c **** 
  12:glcd/graphs.c **** 	Redistribution and use in source and binary forms, with or without
  13:glcd/graphs.c **** 	modification, are permitted provided that the following conditions are met:
  14:glcd/graphs.c **** 		* Redistributions of source code must retain the above copyright
  15:glcd/graphs.c **** 		  notice, this list of conditions and the following disclaimer.
  16:glcd/graphs.c **** 		* Redistributions in binary form must reproduce the above copyright
  17:glcd/graphs.c **** 		  notice, this list of conditions and the following disclaimer in the
  18:glcd/graphs.c **** 		  documentation and/or other materials provided with the distribution.
  19:glcd/graphs.c **** 		* Neither the name of Andy Gock nor the
  20:glcd/graphs.c **** 		  names of its contributors may be used to endorse or promote products
  21:glcd/graphs.c **** 		  derived from this software without specific prior written permission.
  22:glcd/graphs.c **** 
  23:glcd/graphs.c **** 	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  24:glcd/graphs.c **** 	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  25:glcd/graphs.c **** 	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
  26:glcd/graphs.c **** 	DISCLAIMED. IN NO EVENT SHALL ANDY GOCK BE LIABLE FOR ANY
  27:glcd/graphs.c **** 	DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  28:glcd/graphs.c **** 	(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  29:glcd/graphs.c **** 	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  30:glcd/graphs.c **** 	ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  31:glcd/graphs.c **** 	(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  32:glcd/graphs.c **** 	SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  33:glcd/graphs.c **** */
  34:glcd/graphs.c **** 
  35:glcd/graphs.c **** #include "glcd.h"
  36:glcd/graphs.c **** 
  37:glcd/graphs.c **** static uint8_t glcd_map(uint8_t x1, uint8_t x2, uint8_t x);
  38:glcd/graphs.c **** 
  39:glcd/graphs.c **** void glcd_bar_graph_horizontal(uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t val)
  40:glcd/graphs.c **** {
  15               		.loc 1 40 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 EF92      		push r14
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 14, -2
  22 0002 FF92      		push r15
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 15, -3
  26 0004 0F93      		push r16
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 16, -4
  30 0006 1F93      		push r17
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 17, -5
  34 0008 CF93      		push r28
  35               	.LCFI4:
  36               		.cfi_def_cfa_offset 7
  37               		.cfi_offset 28, -6
  38 000a DF93      		push r29
  39               	.LCFI5:
  40               		.cfi_def_cfa_offset 8
  41               		.cfi_offset 29, -7
  42               	/* prologue: function */
  43               	/* frame size = 0 */
  44               	/* stack size = 6 */
  45               	.L__stack_usage = 6
  46 000c F82E      		mov r15,r24
  47 000e 162F      		mov r17,r22
  48 0010 C42F      		mov r28,r20
  49 0012 D22F      		mov r29,r18
  50 0014 E02E      		mov r14,r16
  41:glcd/graphs.c **** 	if (height < 3) {
  51               		.loc 1 41 0
  52 0016 2330      		cpi r18,lo8(3)
  53 0018 00F0      		brlo .L1
  42:glcd/graphs.c **** 		return;
  43:glcd/graphs.c **** 	}
  44:glcd/graphs.c **** 	glcd_draw_rect(x, y, width, height, BLACK);
  54               		.loc 1 44 0
  55 001a 01E0      		ldi r16,lo8(1)
  56               	.LVL1:
  57 001c 0E94 0000 		call glcd_draw_rect
  58               	.LVL2:
  45:glcd/graphs.c **** 	glcd_fill_rect(x+1, y+1, glcd_map(0,width-2,val), height-2 , BLACK);
  59               		.loc 1 45 0
  60 0020 2EEF      		ldi r18,lo8(-2)
  61 0022 2D0F      		add r18,r29
  62 0024 C250      		subi r28,lo8(-(-2))
  63               	.LVL3:
  64               	.LBB24:
  65               	.LBB25:
  46:glcd/graphs.c **** }
  47:glcd/graphs.c **** 
  48:glcd/graphs.c **** void glcd_bar_graph_horizontal_no_border(uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8
  49:glcd/graphs.c **** {
  50:glcd/graphs.c **** 	if (height < 3) {
  51:glcd/graphs.c **** 		return;
  52:glcd/graphs.c **** 	}	
  53:glcd/graphs.c **** 	glcd_fill_rect(x, y, glcd_map(0,width,val), height , BLACK);
  54:glcd/graphs.c **** }
  55:glcd/graphs.c **** 
  56:glcd/graphs.c **** void glcd_bar_graph_vertical(uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t val)
  57:glcd/graphs.c **** {
  58:glcd/graphs.c **** 	glcd_draw_rect(x, y, width, height, BLACK);
  59:glcd/graphs.c **** 	glcd_fill_rect(x+1, y+1+glcd_map(0,height-2,255-val), width-2, height-2-glcd_map(0,height-2,255-va
  60:glcd/graphs.c **** }
  61:glcd/graphs.c **** 
  62:glcd/graphs.c **** void glcd_bar_graph_vertical_no_border(uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t
  63:glcd/graphs.c **** {
  64:glcd/graphs.c **** 	glcd_fill_rect(x, y+glcd_map(0,height-2,255-val), width, height-2-glcd_map(0,height-2,255-val), BL
  65:glcd/graphs.c **** }
  66:glcd/graphs.c **** 
  67:glcd/graphs.c **** void glcd_scrolling_bar_graph(uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t val)
  68:glcd/graphs.c **** {
  69:glcd/graphs.c **** 	uint8_t nx, ny;
  70:glcd/graphs.c **** 	uint8_t color;
  71:glcd/graphs.c **** 	
  72:glcd/graphs.c **** 	/* Draw border of graph */
  73:glcd/graphs.c **** 	glcd_draw_rect(x,y,width,height,BLACK);
  74:glcd/graphs.c **** 	
  75:glcd/graphs.c **** 	/* Scroll inner contents left by one pixel width */
  76:glcd/graphs.c **** 	for (ny = 1; ny <= (height-2); ny++) {
  77:glcd/graphs.c **** 		/* Redraw each horizontal line */
  78:glcd/graphs.c **** 		for (nx = 1; nx <= (width-2); nx += 1) {
  79:glcd/graphs.c **** 			color = glcd_get_pixel(x+nx+1,y+ny);
  80:glcd/graphs.c **** 			glcd_set_pixel(x+nx,y+ny,color);
  81:glcd/graphs.c **** 		}
  82:glcd/graphs.c **** 	}
  83:glcd/graphs.c **** 	
  84:glcd/graphs.c **** 	val = val * (height-3) / 255;
  85:glcd/graphs.c **** 	
  86:glcd/graphs.c **** 	/* Make sure we're not exceeding the size of box interior */
  87:glcd/graphs.c **** 	if (val > (height-3)) {
  88:glcd/graphs.c **** 		val = height - 3;
  89:glcd/graphs.c **** 	}
  90:glcd/graphs.c **** 	
  91:glcd/graphs.c **** 	/* Draw new bar - both black and white portions*/
  92:glcd/graphs.c **** 	glcd_draw_line(x+width-2,y+height-2,x+width-2,y+height-2-val,BLACK);
  93:glcd/graphs.c **** 	glcd_draw_line(x+width-2,y+height-3-val,x+width-2,y+1,WHITE);
  94:glcd/graphs.c **** 	
  95:glcd/graphs.c **** 	/* Write to display */
  96:glcd/graphs.c **** 	glcd_write();
  97:glcd/graphs.c **** }
  98:glcd/graphs.c **** 
  99:glcd/graphs.c **** void glcd_scrolling_bar_graph_timing(uint8_t x, uint8_t y, uint8_t width, uint8_t height, uint8_t v
 100:glcd/graphs.c **** {
 101:glcd/graphs.c **** 	uint8_t n;
 102:glcd/graphs.c **** 	if (line_width == 0) {
 103:glcd/graphs.c **** 		line_width = 1;
 104:glcd/graphs.c **** 	}
 105:glcd/graphs.c **** 	
 106:glcd/graphs.c **** 	/* Adjust graph line's width by just running glcd_scrolling_bar_graph() x number of times */
 107:glcd/graphs.c **** 	/* \todo This should be done differently! */
 108:glcd/graphs.c **** 	for (n=0; n<line_width; n++) {
 109:glcd/graphs.c **** 		glcd_scrolling_bar_graph(x,y,width,height,val);
 110:glcd/graphs.c **** 	}
 111:glcd/graphs.c **** 	
 112:glcd/graphs.c **** 	if (delay) {
 113:glcd/graphs.c **** 		delay_ms(delay);
 114:glcd/graphs.c **** 	}
 115:glcd/graphs.c **** }
 116:glcd/graphs.c **** 
 117:glcd/graphs.c **** static uint8_t glcd_map(uint8_t x1, uint8_t x2, uint8_t x)
 118:glcd/graphs.c **** {
 119:glcd/graphs.c **** 	return x1+(x2-x1)*x/255;	
  66               		.loc 1 119 0
  67 0026 CE9D      		mul r28,r14
  68 0028 C001      		movw r24,r0
  69 002a 1124      		clr __zero_reg__
  70 002c 6FEF      		ldi r22,lo8(-1)
  71 002e 70E0      		ldi r23,0
  72 0030 0E94 0000 		call __divmodhi4
  73 0034 462F      		mov r20,r22
  74               	.LBE25:
  75               	.LBE24:
  45:glcd/graphs.c **** 	glcd_fill_rect(x+1, y+1, glcd_map(0,width-2,val), height-2 , BLACK);
  76               		.loc 1 45 0
  77 0036 61E0      		ldi r22,lo8(1)
  78 0038 610F      		add r22,r17
  79 003a 81E0      		ldi r24,lo8(1)
  80 003c 8F0D      		add r24,r15
  81 003e 0E94 0000 		call glcd_fill_rect
  82               	.LVL4:
  83               	.L1:
  84               	/* epilogue start */
  46:glcd/graphs.c **** }
  85               		.loc 1 46 0
  86 0042 DF91      		pop r29
  87               	.LVL5:
  88 0044 CF91      		pop r28
  89 0046 1F91      		pop r17
  90               	.LVL6:
  91 0048 0F91      		pop r16
  92 004a FF90      		pop r15
  93               	.LVL7:
  94 004c EF90      		pop r14
  95               	.LVL8:
  96 004e 0895      		ret
  97               		.cfi_endproc
  98               	.LFE7:
 100               	.global	glcd_bar_graph_horizontal_no_border
 102               	glcd_bar_graph_horizontal_no_border:
 103               	.LFB8:
  49:glcd/graphs.c **** 	if (height < 3) {
 104               		.loc 1 49 0
 105               		.cfi_startproc
 106               	.LVL9:
 107 0050 0F93      		push r16
 108               	.LCFI6:
 109               		.cfi_def_cfa_offset 3
 110               		.cfi_offset 16, -2
 111               	/* prologue: function */
 112               	/* frame size = 0 */
 113               	/* stack size = 1 */
 114               	.L__stack_usage = 1
 115 0052 382F      		mov r19,r24
 116 0054 E62F      		mov r30,r22
  50:glcd/graphs.c **** 		return;
 117               		.loc 1 50 0
 118 0056 2330      		cpi r18,lo8(3)
 119 0058 00F0      		brlo .L3
 120               	.LBB26:
 121               	.LBB27:
 122               		.loc 1 119 0
 123 005a 409F      		mul r20,r16
 124 005c C001      		movw r24,r0
 125 005e 1124      		clr __zero_reg__
 126               	.LVL10:
 127 0060 6FEF      		ldi r22,lo8(-1)
 128 0062 70E0      		ldi r23,0
 129               	.LVL11:
 130 0064 0E94 0000 		call __divmodhi4
 131 0068 462F      		mov r20,r22
 132               	.LVL12:
 133               	.LBE27:
 134               	.LBE26:
  53:glcd/graphs.c **** }
 135               		.loc 1 53 0
 136 006a 01E0      		ldi r16,lo8(1)
 137               	.LVL13:
 138 006c 6E2F      		mov r22,r30
 139 006e 832F      		mov r24,r19
 140 0070 0E94 0000 		call glcd_fill_rect
 141               	.LVL14:
 142               	.L3:
 143               	/* epilogue start */
  54:glcd/graphs.c **** 
 144               		.loc 1 54 0
 145 0074 0F91      		pop r16
 146 0076 0895      		ret
 147               		.cfi_endproc
 148               	.LFE8:
 150               	.global	glcd_bar_graph_vertical
 152               	glcd_bar_graph_vertical:
 153               	.LFB9:
  57:glcd/graphs.c **** 	glcd_draw_rect(x, y, width, height, BLACK);
 154               		.loc 1 57 0
 155               		.cfi_startproc
 156               	.LVL15:
 157 0078 EF92      		push r14
 158               	.LCFI7:
 159               		.cfi_def_cfa_offset 3
 160               		.cfi_offset 14, -2
 161 007a FF92      		push r15
 162               	.LCFI8:
 163               		.cfi_def_cfa_offset 4
 164               		.cfi_offset 15, -3
 165 007c 0F93      		push r16
 166               	.LCFI9:
 167               		.cfi_def_cfa_offset 5
 168               		.cfi_offset 16, -4
 169 007e 1F93      		push r17
 170               	.LCFI10:
 171               		.cfi_def_cfa_offset 6
 172               		.cfi_offset 17, -5
 173 0080 CF93      		push r28
 174               	.LCFI11:
 175               		.cfi_def_cfa_offset 7
 176               		.cfi_offset 28, -6
 177 0082 DF93      		push r29
 178               	.LCFI12:
 179               		.cfi_def_cfa_offset 8
 180               		.cfi_offset 29, -7
 181               	/* prologue: function */
 182               	/* frame size = 0 */
 183               	/* stack size = 6 */
 184               	.L__stack_usage = 6
 185 0084 E82E      		mov r14,r24
 186 0086 D62F      		mov r29,r22
 187 0088 F42E      		mov r15,r20
 188 008a C22F      		mov r28,r18
 189 008c 102F      		mov r17,r16
  58:glcd/graphs.c **** 	glcd_fill_rect(x+1, y+1+glcd_map(0,height-2,255-val), width-2, height-2-glcd_map(0,height-2,255-va
 190               		.loc 1 58 0
 191 008e 01E0      		ldi r16,lo8(1)
 192               	.LVL16:
 193 0090 0E94 0000 		call glcd_draw_rect
 194               	.LVL17:
  59:glcd/graphs.c **** }
 195               		.loc 1 59 0
 196 0094 C250      		subi r28,lo8(-(-2))
 197               	.LVL18:
 198 0096 1095      		com r17
 199               	.LVL19:
 200               	.LBB28:
 201               	.LBB29:
 202               		.loc 1 119 0
 203 0098 1C9F      		mul r17,r28
 204 009a C001      		movw r24,r0
 205 009c 1124      		clr __zero_reg__
 206 009e 6FEF      		ldi r22,lo8(-1)
 207 00a0 70E0      		ldi r23,0
 208 00a2 0E94 0000 		call __divmodhi4
 209               	.LVL20:
 210               	.LBE29:
 211               	.LBE28:
  59:glcd/graphs.c **** }
 212               		.loc 1 59 0
 213 00a6 2C2F      		mov r18,r28
 214 00a8 261B      		sub r18,r22
 215 00aa 4EEF      		ldi r20,lo8(-2)
 216 00ac 4F0D      		add r20,r15
 217 00ae DF5F      		subi r29,lo8(-(1))
 218               	.LVL21:
 219 00b0 6D0F      		add r22,r29
 220 00b2 81E0      		ldi r24,lo8(1)
 221 00b4 8E0D      		add r24,r14
 222 00b6 0E94 0000 		call glcd_fill_rect
 223               	.LVL22:
 224               	/* epilogue start */
  60:glcd/graphs.c **** 
 225               		.loc 1 60 0
 226 00ba DF91      		pop r29
 227               	.LVL23:
 228 00bc CF91      		pop r28
 229               	.LVL24:
 230 00be 1F91      		pop r17
 231               	.LVL25:
 232 00c0 0F91      		pop r16
 233 00c2 FF90      		pop r15
 234               	.LVL26:
 235 00c4 EF90      		pop r14
 236               	.LVL27:
 237 00c6 0895      		ret
 238               		.cfi_endproc
 239               	.LFE9:
 241               	.global	glcd_bar_graph_vertical_no_border
 243               	glcd_bar_graph_vertical_no_border:
 244               	.LFB10:
  63:glcd/graphs.c **** 	glcd_fill_rect(x, y+glcd_map(0,height-2,255-val), width, height-2-glcd_map(0,height-2,255-val), BL
 245               		.loc 1 63 0
 246               		.cfi_startproc
 247               	.LVL28:
 248 00c8 0F93      		push r16
 249               	.LCFI13:
 250               		.cfi_def_cfa_offset 3
 251               		.cfi_offset 16, -2
 252               	/* prologue: function */
 253               	/* frame size = 0 */
 254               	/* stack size = 1 */
 255               	.L__stack_usage = 1
 256 00ca E82F      		mov r30,r24
 257 00cc 362F      		mov r19,r22
  64:glcd/graphs.c **** }
 258               		.loc 1 64 0
 259 00ce 2250      		subi r18,lo8(-(-2))
 260               	.LVL29:
 261 00d0 0095      		com r16
 262               	.LVL30:
 263               	.LBB30:
 264               	.LBB31:
 265               		.loc 1 119 0
 266 00d2 029F      		mul r16,r18
 267 00d4 C001      		movw r24,r0
 268 00d6 1124      		clr __zero_reg__
 269               	.LVL31:
 270 00d8 6FEF      		ldi r22,lo8(-1)
 271 00da 70E0      		ldi r23,0
 272               	.LVL32:
 273 00dc 0E94 0000 		call __divmodhi4
 274               	.LVL33:
 275               	.LBE31:
 276               	.LBE30:
  64:glcd/graphs.c **** }
 277               		.loc 1 64 0
 278 00e0 261B      		sub r18,r22
 279               	.LVL34:
 280 00e2 630F      		add r22,r19
 281 00e4 01E0      		ldi r16,lo8(1)
 282 00e6 8E2F      		mov r24,r30
 283 00e8 0E94 0000 		call glcd_fill_rect
 284               	.LVL35:
 285               	/* epilogue start */
  65:glcd/graphs.c **** 
 286               		.loc 1 65 0
 287 00ec 0F91      		pop r16
 288 00ee 0895      		ret
 289               		.cfi_endproc
 290               	.LFE10:
 292               	.global	glcd_scrolling_bar_graph
 294               	glcd_scrolling_bar_graph:
 295               	.LFB11:
  68:glcd/graphs.c **** 	uint8_t nx, ny;
 296               		.loc 1 68 0
 297               		.cfi_startproc
 298               	.LVL36:
 299 00f0 4F92      		push r4
 300               	.LCFI14:
 301               		.cfi_def_cfa_offset 3
 302               		.cfi_offset 4, -2
 303 00f2 5F92      		push r5
 304               	.LCFI15:
 305               		.cfi_def_cfa_offset 4
 306               		.cfi_offset 5, -3
 307 00f4 6F92      		push r6
 308               	.LCFI16:
 309               		.cfi_def_cfa_offset 5
 310               		.cfi_offset 6, -4
 311 00f6 7F92      		push r7
 312               	.LCFI17:
 313               		.cfi_def_cfa_offset 6
 314               		.cfi_offset 7, -5
 315 00f8 8F92      		push r8
 316               	.LCFI18:
 317               		.cfi_def_cfa_offset 7
 318               		.cfi_offset 8, -6
 319 00fa 9F92      		push r9
 320               	.LCFI19:
 321               		.cfi_def_cfa_offset 8
 322               		.cfi_offset 9, -7
 323 00fc AF92      		push r10
 324               	.LCFI20:
 325               		.cfi_def_cfa_offset 9
 326               		.cfi_offset 10, -8
 327 00fe BF92      		push r11
 328               	.LCFI21:
 329               		.cfi_def_cfa_offset 10
 330               		.cfi_offset 11, -9
 331 0100 CF92      		push r12
 332               	.LCFI22:
 333               		.cfi_def_cfa_offset 11
 334               		.cfi_offset 12, -10
 335 0102 DF92      		push r13
 336               	.LCFI23:
 337               		.cfi_def_cfa_offset 12
 338               		.cfi_offset 13, -11
 339 0104 EF92      		push r14
 340               	.LCFI24:
 341               		.cfi_def_cfa_offset 13
 342               		.cfi_offset 14, -12
 343 0106 FF92      		push r15
 344               	.LCFI25:
 345               		.cfi_def_cfa_offset 14
 346               		.cfi_offset 15, -13
 347 0108 0F93      		push r16
 348               	.LCFI26:
 349               		.cfi_def_cfa_offset 15
 350               		.cfi_offset 16, -14
 351 010a 1F93      		push r17
 352               	.LCFI27:
 353               		.cfi_def_cfa_offset 16
 354               		.cfi_offset 17, -15
 355 010c CF93      		push r28
 356               	.LCFI28:
 357               		.cfi_def_cfa_offset 17
 358               		.cfi_offset 28, -16
 359 010e DF93      		push r29
 360               	.LCFI29:
 361               		.cfi_def_cfa_offset 18
 362               		.cfi_offset 29, -17
 363               	/* prologue: function */
 364               	/* frame size = 0 */
 365               	/* stack size = 16 */
 366               	.L__stack_usage = 16
 367 0110 D82E      		mov r13,r24
 368 0112 162F      		mov r17,r22
 369 0114 C42F      		mov r28,r20
 370 0116 D22F      		mov r29,r18
 371 0118 502E      		mov r5,r16
  73:glcd/graphs.c **** 	
 372               		.loc 1 73 0
 373 011a 01E0      		ldi r16,lo8(1)
 374               	.LVL37:
 375 011c 0E94 0000 		call glcd_draw_rect
 376               	.LVL38:
  76:glcd/graphs.c **** 		/* Redraw each horizontal line */
 377               		.loc 1 76 0
 378 0120 ED2E      		mov r14,r29
 379 0122 F12C      		mov r15,__zero_reg__
 380 0124 4701      		movw r8,r14
 381 0126 21E0      		ldi r18,1
 382 0128 821A      		sub r8,r18
 383 012a 9108      		sbc r9,__zero_reg__
 384 012c 4424      		clr r4
 385 012e 4394      		inc r4
 386 0130 4D0C      		add r4,r13
  78:glcd/graphs.c **** 			color = glcd_get_pixel(x+nx+1,y+ny);
 387               		.loc 1 78 0
 388 0132 AC2E      		mov r10,r28
 389 0134 B12C      		mov r11,__zero_reg__
 390 0136 81E0      		ldi r24,1
 391 0138 A81A      		sub r10,r24
 392 013a B108      		sbc r11,__zero_reg__
 393               	.LVL39:
 394               	.L8:
  76:glcd/graphs.c **** 		/* Redraw each horizontal line */
 395               		.loc 1 76 0 discriminator 1
 396 013c 802F      		mov r24,r16
 397 013e 90E0      		ldi r25,0
 398 0140 8815      		cp r24,r8
 399 0142 9905      		cpc r25,r9
 400 0144 04F4      		brge .L10
 401 0146 C42C      		mov r12,r4
 402 0148 702E      		mov r7,r16
 403 014a 710E      		add r7,r17
 404 014c 00C0      		rjmp .L11
 405               	.LVL40:
 406               	.L9:
  79:glcd/graphs.c **** 			glcd_set_pixel(x+nx,y+ny,color);
 407               		.loc 1 79 0 discriminator 3
 408 014e 672D      		mov r22,r7
 409 0150 862D      		mov r24,r6
 410               	.LVL41:
 411 0152 0E94 0000 		call glcd_get_pixel
 412               	.LVL42:
  80:glcd/graphs.c **** 		}
 413               		.loc 1 80 0 discriminator 3
 414 0156 482F      		mov r20,r24
 415 0158 672D      		mov r22,r7
 416 015a 8C2D      		mov r24,r12
 417               	.LVL43:
 418 015c 0E94 0000 		call glcd_set_pixel
 419               	.LVL44:
 420 0160 C62C      		mov r12,r6
 421               	.LVL45:
 422               	.L11:
 423 0162 6624      		clr r6
 424 0164 6394      		inc r6
 425 0166 6C0C      		add r6,r12
  78:glcd/graphs.c **** 			color = glcd_get_pixel(x+nx+1,y+ny);
 426               		.loc 1 78 0 discriminator 1
 427 0168 8C2D      		mov r24,r12
 428 016a 8D19      		sub r24,r13
 429               	.LVL46:
 430 016c 90E0      		ldi r25,0
 431 016e 8A15      		cp r24,r10
 432 0170 9B05      		cpc r25,r11
 433 0172 04F0      		brlt .L9
  76:glcd/graphs.c **** 		/* Redraw each horizontal line */
 434               		.loc 1 76 0 discriminator 2
 435 0174 0F5F      		subi r16,lo8(-(1))
 436               	.LVL47:
 437 0176 00C0      		rjmp .L8
 438               	.LVL48:
 439               	.L10:
  84:glcd/graphs.c **** 	
 440               		.loc 1 84 0
 441 0178 9701      		movw r18,r14
 442 017a 2350      		subi r18,3
 443 017c 3109      		sbc r19,__zero_reg__
 444 017e 529E      		mul r5,r18
 445 0180 C001      		movw r24,r0
 446 0182 539E      		mul r5,r19
 447 0184 900D      		add r25,r0
 448 0186 1124      		clr __zero_reg__
 449 0188 6FEF      		ldi r22,lo8(-1)
 450 018a 70E0      		ldi r23,0
 451 018c 0E94 0000 		call __divmodhi4
 452               	.LVL49:
  87:glcd/graphs.c **** 		val = height - 3;
 453               		.loc 1 87 0
 454 0190 CB01      		movw r24,r22
 455 0192 9927      		clr r25
 456 0194 22E0      		ldi r18,2
 457 0196 E21A      		sub r14,r18
 458 0198 F108      		sbc r15,__zero_reg__
 459 019a 8E15      		cp r24,r14
 460 019c 9F05      		cpc r25,r15
 461 019e 04F0      		brlt .L13
  88:glcd/graphs.c **** 	}
 462               		.loc 1 88 0
 463 01a0 6DEF      		ldi r22,lo8(-3)
 464               	.LVL50:
 465 01a2 6D0F      		add r22,r29
 466               	.LVL51:
 467               	.L13:
  92:glcd/graphs.c **** 	glcd_draw_line(x+width-2,y+height-3-val,x+width-2,y+1,WHITE);
 468               		.loc 1 92 0
 469 01a4 D10F      		add r29,r17
 470               	.LVL52:
 471 01a6 FD2E      		mov r15,r29
 472 01a8 F61A      		sub r15,r22
 473 01aa C250      		subi r28,lo8(-(-2))
 474               	.LVL53:
 475 01ac CD0D      		add r28,r13
 476               	.LVL54:
 477 01ae 2EEF      		ldi r18,lo8(-2)
 478 01b0 2F0D      		add r18,r15
 479 01b2 6EEF      		ldi r22,lo8(-2)
 480               	.LVL55:
 481 01b4 6D0F      		add r22,r29
 482 01b6 01E0      		ldi r16,lo8(1)
 483               	.LVL56:
 484 01b8 4C2F      		mov r20,r28
 485 01ba 8C2F      		mov r24,r28
 486 01bc 0E94 0000 		call glcd_draw_line
 487               	.LVL57:
  93:glcd/graphs.c **** 	
 488               		.loc 1 93 0
 489 01c0 21E0      		ldi r18,lo8(1)
 490 01c2 210F      		add r18,r17
 491 01c4 6DEF      		ldi r22,lo8(-3)
 492 01c6 6F0D      		add r22,r15
 493 01c8 00E0      		ldi r16,0
 494 01ca 4C2F      		mov r20,r28
 495 01cc 8C2F      		mov r24,r28
 496 01ce 0E94 0000 		call glcd_draw_line
 497               	.LVL58:
 498               	/* epilogue start */
  97:glcd/graphs.c **** 
 499               		.loc 1 97 0
 500 01d2 DF91      		pop r29
 501 01d4 CF91      		pop r28
 502 01d6 1F91      		pop r17
 503               	.LVL59:
 504 01d8 0F91      		pop r16
 505 01da FF90      		pop r15
 506 01dc EF90      		pop r14
 507 01de DF90      		pop r13
 508               	.LVL60:
 509 01e0 CF90      		pop r12
 510 01e2 BF90      		pop r11
 511 01e4 AF90      		pop r10
 512 01e6 9F90      		pop r9
 513 01e8 8F90      		pop r8
 514 01ea 7F90      		pop r7
 515 01ec 6F90      		pop r6
 516 01ee 5F90      		pop r5
 517 01f0 4F90      		pop r4
  96:glcd/graphs.c **** }
 518               		.loc 1 96 0
 519 01f2 0C94 0000 		jmp glcd_write
 520               	.LVL61:
 521               		.cfi_endproc
 522               	.LFE11:
 524               	.global	__floatunsisf
 525               	.global	__mulsf3
 526               	.global	__ltsf2
 527               	.global	__gtsf2
 528               	.global	__fixunssfsi
 529               	.global	glcd_scrolling_bar_graph_timing
 531               	glcd_scrolling_bar_graph_timing:
 532               	.LFB12:
 100:glcd/graphs.c **** 	uint8_t n;
 533               		.loc 1 100 0
 534               		.cfi_startproc
 535               	.LVL62:
 536 01f6 8F92      		push r8
 537               	.LCFI30:
 538               		.cfi_def_cfa_offset 3
 539               		.cfi_offset 8, -2
 540 01f8 9F92      		push r9
 541               	.LCFI31:
 542               		.cfi_def_cfa_offset 4
 543               		.cfi_offset 9, -3
 544 01fa AF92      		push r10
 545               	.LCFI32:
 546               		.cfi_def_cfa_offset 5
 547               		.cfi_offset 10, -4
 548 01fc BF92      		push r11
 549               	.LCFI33:
 550               		.cfi_def_cfa_offset 6
 551               		.cfi_offset 11, -5
 552 01fe CF92      		push r12
 553               	.LCFI34:
 554               		.cfi_def_cfa_offset 7
 555               		.cfi_offset 12, -6
 556 0200 DF92      		push r13
 557               	.LCFI35:
 558               		.cfi_def_cfa_offset 8
 559               		.cfi_offset 13, -7
 560 0202 EF92      		push r14
 561               	.LCFI36:
 562               		.cfi_def_cfa_offset 9
 563               		.cfi_offset 14, -8
 564 0204 FF92      		push r15
 565               	.LCFI37:
 566               		.cfi_def_cfa_offset 10
 567               		.cfi_offset 15, -9
 568 0206 0F93      		push r16
 569               	.LCFI38:
 570               		.cfi_def_cfa_offset 11
 571               		.cfi_offset 16, -10
 572 0208 CF93      		push r28
 573               	.LCFI39:
 574               		.cfi_def_cfa_offset 12
 575               		.cfi_offset 28, -11
 576               	/* prologue: function */
 577               	/* frame size = 0 */
 578               	/* stack size = 10 */
 579               	.L__stack_usage = 10
 580 020a B82E      		mov r11,r24
 581 020c A62E      		mov r10,r22
 582 020e 942E      		mov r9,r20
 583 0210 822E      		mov r8,r18
 584 0212 C02F      		mov r28,r16
 102:glcd/graphs.c **** 		line_width = 1;
 585               		.loc 1 102 0
 586 0214 E110      		cpse r14,__zero_reg__
 587 0216 00C0      		rjmp .L15
 103:glcd/graphs.c **** 	}
 588               		.loc 1 103 0
 589 0218 EE24      		clr r14
 590 021a E394      		inc r14
 591               	.LVL63:
 592               	.L15:
 108:glcd/graphs.c **** 		glcd_scrolling_bar_graph(x,y,width,height,val);
 593               		.loc 1 108 0
 594 021c F12C      		mov r15,__zero_reg__
 595               	.LVL64:
 596               	.L16:
 109:glcd/graphs.c **** 	}
 597               		.loc 1 109 0 discriminator 3
 598 021e 0C2F      		mov r16,r28
 599               	.LVL65:
 600 0220 282D      		mov r18,r8
 601 0222 492D      		mov r20,r9
 602 0224 6A2D      		mov r22,r10
 603 0226 8B2D      		mov r24,r11
 604 0228 0E94 0000 		call glcd_scrolling_bar_graph
 605               	.LVL66:
 108:glcd/graphs.c **** 		glcd_scrolling_bar_graph(x,y,width,height,val);
 606               		.loc 1 108 0 discriminator 3
 607 022c F394      		inc r15
 608               	.LVL67:
 609 022e EF10      		cpse r14,r15
 610 0230 00C0      		rjmp .L16
 611               	.LVL68:
 112:glcd/graphs.c **** 		delay_ms(delay);
 612               		.loc 1 112 0
 613 0232 C114      		cp r12,__zero_reg__
 614 0234 D104      		cpc r13,__zero_reg__
 615 0236 01F0      		breq .L14
 113:glcd/graphs.c **** 	}
 616               		.loc 1 113 0
 617 0238 B601      		movw r22,r12
 618 023a 80E0      		ldi r24,0
 619 023c 90E0      		ldi r25,0
 620 023e 0E94 0000 		call __floatunsisf
 621               	.LVL69:
 622 0242 4B01      		movw r8,r22
 623 0244 5C01      		movw r10,r24
 624               	.LVL70:
 625               	.LBB32:
 626               	.LBB33:
 627               		.file 2 "/usr/avr/include/util/delay.h"
   1:/usr/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/avr/include/util/delay.h **** 
   6:/usr/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/avr/include/util/delay.h **** 
   9:/usr/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/avr/include/util/delay.h **** 
  12:/usr/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/avr/include/util/delay.h ****      distribution.
  16:/usr/avr/include/util/delay.h **** 
  17:/usr/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/avr/include/util/delay.h **** 
  21:/usr/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/avr/include/util/delay.h **** 
  33:/usr/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/avr/include/util/delay.h **** 
  35:/usr/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/avr/include/util/delay.h **** 
  38:/usr/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/avr/include/util/delay.h **** #  endif
  42:/usr/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/avr/include/util/delay.h **** 
  44:/usr/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/avr/include/util/delay.h **** #include <math.h>
  47:/usr/avr/include/util/delay.h **** 
  48:/usr/avr/include/util/delay.h **** /** \file */
  49:/usr/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/avr/include/util/delay.h ****     \code
  51:/usr/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/avr/include/util/delay.h ****     \endcode
  55:/usr/avr/include/util/delay.h **** 
  56:/usr/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/avr/include/util/delay.h ****     used.
  60:/usr/avr/include/util/delay.h **** 
  61:/usr/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/avr/include/util/delay.h **** 
  70:/usr/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/avr/include/util/delay.h **** 
  79:/usr/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/avr/include/util/delay.h **** 
  83:/usr/avr/include/util/delay.h **** */
  84:/usr/avr/include/util/delay.h **** 
  85:/usr/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/avr/include/util/delay.h **** #endif
  89:/usr/avr/include/util/delay.h **** 
  90:/usr/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/avr/include/util/delay.h **** 
  97:/usr/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/avr/include/util/delay.h **** 
 103:/usr/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/avr/include/util/delay.h ****     integer value.
 107:/usr/avr/include/util/delay.h ****  */
 108:/usr/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/avr/include/util/delay.h **** #endif
 110:/usr/avr/include/util/delay.h **** 
 111:/usr/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/avr/include/util/delay.h **** #endif
 114:/usr/avr/include/util/delay.h **** 
 115:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/avr/include/util/delay.h **** #endif
 120:/usr/avr/include/util/delay.h **** 
 121:/usr/avr/include/util/delay.h **** /**
 122:/usr/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/avr/include/util/delay.h **** 
 124:/usr/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/avr/include/util/delay.h **** 
 126:/usr/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/avr/include/util/delay.h **** 
 129:/usr/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/avr/include/util/delay.h **** 
 131:/usr/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/avr/include/util/delay.h **** 
 137:/usr/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/avr/include/util/delay.h **** 
 142:/usr/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/avr/include/util/delay.h **** 
 147:/usr/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/avr/include/util/delay.h ****    respectively.
 151:/usr/avr/include/util/delay.h **** 
 152:/usr/avr/include/util/delay.h ****    \note
 153:/usr/avr/include/util/delay.h **** 
 154:/usr/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/avr/include/util/delay.h **** 
 164:/usr/avr/include/util/delay.h ****  */
 165:/usr/avr/include/util/delay.h **** void
 166:/usr/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/avr/include/util/delay.h **** {
 168:/usr/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/avr/include/util/delay.h **** 
 176:/usr/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/avr/include/util/delay.h **** 
 179:/usr/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/avr/include/util/delay.h **** 
 182:/usr/avr/include/util/delay.h **** 	#else
 183:/usr/avr/include/util/delay.h **** 		//round up by default
 184:/usr/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/avr/include/util/delay.h **** 	#endif
 186:/usr/avr/include/util/delay.h **** 
 187:/usr/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/avr/include/util/delay.h **** 
 189:/usr/avr/include/util/delay.h **** #else
 190:/usr/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 628               		.loc 2 191 0
 629 0246 20E0      		ldi r18,0
 630 0248 30E0      		ldi r19,0
 631 024a 4AE7      		ldi r20,lo8(122)
 632 024c 55E4      		ldi r21,lo8(69)
 633 024e 0E94 0000 		call __mulsf3
 634               	.LVL71:
 635 0252 6B01      		movw r12,r22
 636 0254 7C01      		movw r14,r24
 637               	.LVL72:
 192:/usr/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 638               		.loc 2 192 0
 639 0256 20E0      		ldi r18,0
 640 0258 30E0      		ldi r19,0
 641 025a 40E8      		ldi r20,lo8(-128)
 642 025c 5FE3      		ldi r21,lo8(63)
 643 025e 0E94 0000 		call __ltsf2
 644               	.LVL73:
 645 0262 87FD      		sbrc r24,7
 646 0264 00C0      		rjmp .L23
 193:/usr/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 647               		.loc 2 194 0
 648 0266 20E0      		ldi r18,0
 649 0268 3FEF      		ldi r19,lo8(-1)
 650 026a 4FE7      		ldi r20,lo8(127)
 651 026c 57E4      		ldi r21,lo8(71)
 652 026e C701      		movw r24,r14
 653 0270 B601      		movw r22,r12
 654 0272 0E94 0000 		call __gtsf2
 655               	.LVL74:
 656 0276 1816      		cp __zero_reg__,r24
 657 0278 04F4      		brge .L29
 195:/usr/avr/include/util/delay.h **** 	{
 196:/usr/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 658               		.loc 2 197 0
 659 027a 20E0      		ldi r18,0
 660 027c 30E0      		ldi r19,0
 661 027e 40E2      		ldi r20,lo8(32)
 662 0280 51E4      		ldi r21,lo8(65)
 663 0282 C501      		movw r24,r10
 664 0284 B401      		movw r22,r8
 665 0286 0E94 0000 		call __mulsf3
 666               	.LVL75:
 667 028a 0E94 0000 		call __fixunssfsi
 668               	.LVL76:
 669               	.LBB34:
 670               	.LBB35:
 671               		.file 3 "/usr/avr/include/util/delay_basic.h"
   1:/usr/avr/include/util/delay_basic.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/avr/include/util/delay_basic.h ****    Copyright (c) 2007 Joerg Wunsch
   3:/usr/avr/include/util/delay_basic.h ****    All rights reserved.
   4:/usr/avr/include/util/delay_basic.h **** 
   5:/usr/avr/include/util/delay_basic.h ****    Redistribution and use in source and binary forms, with or without
   6:/usr/avr/include/util/delay_basic.h ****    modification, are permitted provided that the following conditions are met:
   7:/usr/avr/include/util/delay_basic.h **** 
   8:/usr/avr/include/util/delay_basic.h ****    * Redistributions of source code must retain the above copyright
   9:/usr/avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer.
  10:/usr/avr/include/util/delay_basic.h **** 
  11:/usr/avr/include/util/delay_basic.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/usr/avr/include/util/delay_basic.h ****      notice, this list of conditions and the following disclaimer in
  13:/usr/avr/include/util/delay_basic.h ****      the documentation and/or other materials provided with the
  14:/usr/avr/include/util/delay_basic.h ****      distribution.
  15:/usr/avr/include/util/delay_basic.h **** 
  16:/usr/avr/include/util/delay_basic.h ****    * Neither the name of the copyright holders nor the names of
  17:/usr/avr/include/util/delay_basic.h ****      contributors may be used to endorse or promote products derived
  18:/usr/avr/include/util/delay_basic.h ****      from this software without specific prior written permission.
  19:/usr/avr/include/util/delay_basic.h **** 
  20:/usr/avr/include/util/delay_basic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/usr/avr/include/util/delay_basic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/usr/avr/include/util/delay_basic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/usr/avr/include/util/delay_basic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/usr/avr/include/util/delay_basic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/usr/avr/include/util/delay_basic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/usr/avr/include/util/delay_basic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/usr/avr/include/util/delay_basic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/usr/avr/include/util/delay_basic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/usr/avr/include/util/delay_basic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/usr/avr/include/util/delay_basic.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/usr/avr/include/util/delay_basic.h **** 
  32:/usr/avr/include/util/delay_basic.h **** /* $Id: delay_basic.h 2453 2014-10-19 08:18:11Z saaadhu $ */
  33:/usr/avr/include/util/delay_basic.h **** 
  34:/usr/avr/include/util/delay_basic.h **** #ifndef _UTIL_DELAY_BASIC_H_
  35:/usr/avr/include/util/delay_basic.h **** #define _UTIL_DELAY_BASIC_H_ 1
  36:/usr/avr/include/util/delay_basic.h **** 
  37:/usr/avr/include/util/delay_basic.h **** #include <inttypes.h>
  38:/usr/avr/include/util/delay_basic.h **** 
  39:/usr/avr/include/util/delay_basic.h **** #if !defined(__DOXYGEN__)
  40:/usr/avr/include/util/delay_basic.h **** static __inline__ void _delay_loop_1(uint8_t __count) __attribute__((__always_inline__));
  41:/usr/avr/include/util/delay_basic.h **** static __inline__ void _delay_loop_2(uint16_t __count) __attribute__((__always_inline__));
  42:/usr/avr/include/util/delay_basic.h **** #endif
  43:/usr/avr/include/util/delay_basic.h **** 
  44:/usr/avr/include/util/delay_basic.h **** /** \file */
  45:/usr/avr/include/util/delay_basic.h **** /** \defgroup util_delay_basic <util/delay_basic.h>: Basic busy-wait delay loops
  46:/usr/avr/include/util/delay_basic.h ****     \code
  47:/usr/avr/include/util/delay_basic.h ****     #include <util/delay_basic.h>
  48:/usr/avr/include/util/delay_basic.h ****     \endcode
  49:/usr/avr/include/util/delay_basic.h **** 
  50:/usr/avr/include/util/delay_basic.h ****     The functions in this header file implement simple delay loops
  51:/usr/avr/include/util/delay_basic.h ****     that perform a busy-waiting.  They are typically used to
  52:/usr/avr/include/util/delay_basic.h ****     facilitate short delays in the program execution.  They are
  53:/usr/avr/include/util/delay_basic.h ****     implemented as count-down loops with a well-known CPU cycle
  54:/usr/avr/include/util/delay_basic.h ****     count per loop iteration.  As such, no other processing can
  55:/usr/avr/include/util/delay_basic.h ****     occur simultaneously.  It should be kept in mind that the
  56:/usr/avr/include/util/delay_basic.h ****     functions described here do not disable interrupts.
  57:/usr/avr/include/util/delay_basic.h **** 
  58:/usr/avr/include/util/delay_basic.h ****     In general, for long delays, the use of hardware timers is
  59:/usr/avr/include/util/delay_basic.h ****     much preferrable, as they free the CPU, and allow for
  60:/usr/avr/include/util/delay_basic.h ****     concurrent processing of other events while the timer is
  61:/usr/avr/include/util/delay_basic.h ****     running.  However, in particular for very short delays, the
  62:/usr/avr/include/util/delay_basic.h ****     overhead of setting up a hardware timer is too much compared
  63:/usr/avr/include/util/delay_basic.h ****     to the overall delay time.
  64:/usr/avr/include/util/delay_basic.h **** 
  65:/usr/avr/include/util/delay_basic.h ****     Two inline functions are provided for the actual delay algorithms.
  66:/usr/avr/include/util/delay_basic.h **** 
  67:/usr/avr/include/util/delay_basic.h **** */
  68:/usr/avr/include/util/delay_basic.h **** 
  69:/usr/avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  70:/usr/avr/include/util/delay_basic.h **** 
  71:/usr/avr/include/util/delay_basic.h ****     Delay loop using an 8-bit counter \c __count, so up to 256
  72:/usr/avr/include/util/delay_basic.h ****     iterations are possible.  (The value 256 would have to be passed
  73:/usr/avr/include/util/delay_basic.h ****     as 0.)  The loop executes three CPU cycles per iteration, not
  74:/usr/avr/include/util/delay_basic.h ****     including the overhead the compiler needs to setup the counter
  75:/usr/avr/include/util/delay_basic.h ****     register.
  76:/usr/avr/include/util/delay_basic.h **** 
  77:/usr/avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to 768 microseconds
  78:/usr/avr/include/util/delay_basic.h ****     can be achieved.
  79:/usr/avr/include/util/delay_basic.h **** */
  80:/usr/avr/include/util/delay_basic.h **** void
  81:/usr/avr/include/util/delay_basic.h **** _delay_loop_1(uint8_t __count)
  82:/usr/avr/include/util/delay_basic.h **** {
  83:/usr/avr/include/util/delay_basic.h **** 	__asm__ volatile (
  84:/usr/avr/include/util/delay_basic.h **** 		"1: dec %0" "\n\t"
  85:/usr/avr/include/util/delay_basic.h **** 		"brne 1b"
  86:/usr/avr/include/util/delay_basic.h **** 		: "=r" (__count)
  87:/usr/avr/include/util/delay_basic.h **** 		: "0" (__count)
  88:/usr/avr/include/util/delay_basic.h **** 	);
  89:/usr/avr/include/util/delay_basic.h **** }
  90:/usr/avr/include/util/delay_basic.h **** 
  91:/usr/avr/include/util/delay_basic.h **** /** \ingroup util_delay_basic
  92:/usr/avr/include/util/delay_basic.h **** 
  93:/usr/avr/include/util/delay_basic.h ****     Delay loop using a 16-bit counter \c __count, so up to 65536
  94:/usr/avr/include/util/delay_basic.h ****     iterations are possible.  (The value 65536 would have to be
  95:/usr/avr/include/util/delay_basic.h ****     passed as 0.)  The loop executes four CPU cycles per iteration,
  96:/usr/avr/include/util/delay_basic.h ****     not including the overhead the compiler requires to setup the
  97:/usr/avr/include/util/delay_basic.h ****     counter register pair.
  98:/usr/avr/include/util/delay_basic.h **** 
  99:/usr/avr/include/util/delay_basic.h ****     Thus, at a CPU speed of 1 MHz, delays of up to about 262.1
 100:/usr/avr/include/util/delay_basic.h ****     milliseconds can be achieved.
 101:/usr/avr/include/util/delay_basic.h ****  */
 102:/usr/avr/include/util/delay_basic.h **** void
 103:/usr/avr/include/util/delay_basic.h **** _delay_loop_2(uint16_t __count)
 104:/usr/avr/include/util/delay_basic.h **** {
 105:/usr/avr/include/util/delay_basic.h **** 	__asm__ volatile (
 672               		.loc 3 105 0
 673 028e 20E9      		ldi r18,lo8(-112)
 674 0290 31E0      		ldi r19,lo8(1)
 675               	.L21:
 676               	.LVL77:
 677               	.LBE35:
 678               	.LBE34:
 198:/usr/avr/include/util/delay.h **** 		while(__ticks)
 679               		.loc 2 198 0
 680 0292 6115      		cp r22,__zero_reg__
 681 0294 7105      		cpc r23,__zero_reg__
 682 0296 01F4      		brne .L22
 683               	.LVL78:
 684               	.L14:
 685               	/* epilogue start */
 686               	.LBE33:
 687               	.LBE32:
 115:glcd/graphs.c **** 
 688               		.loc 1 115 0
 689 0298 CF91      		pop r28
 690 029a 0F91      		pop r16
 691               	.LVL79:
 692 029c FF90      		pop r15
 693               	.LVL80:
 694 029e EF90      		pop r14
 695               	.LVL81:
 696 02a0 DF90      		pop r13
 697 02a2 CF90      		pop r12
 698 02a4 BF90      		pop r11
 699               	.LVL82:
 700 02a6 AF90      		pop r10
 701               	.LVL83:
 702 02a8 9F90      		pop r9
 703               	.LVL84:
 704 02aa 8F90      		pop r8
 705 02ac 0895      		ret
 706               	.LVL85:
 707               	.L22:
 708               	.LBB42:
 709               	.LBB40:
 710               	.LBB37:
 711               	.LBB36:
 712               		.loc 3 105 0
 713 02ae C901      		movw r24,r18
 714               	/* #APP */
 715               	 ;  105 "/usr/avr/include/util/delay_basic.h" 1
 716 02b0 0197      		1: sbiw r24,1
 717 02b2 01F4      		brne 1b
 718               	 ;  0 "" 2
 719               	.LVL86:
 720               	/* #NOAPP */
 721               	.LBE36:
 722               	.LBE37:
 199:/usr/avr/include/util/delay.h **** 		{
 200:/usr/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/avr/include/util/delay.h **** 			__ticks --;
 723               		.loc 2 202 0
 724 02b4 6150      		subi r22,1
 725 02b6 7109      		sbc r23,__zero_reg__
 726               	.LVL87:
 727 02b8 00C0      		rjmp .L21
 728               	.LVL88:
 729               	.L29:
 203:/usr/avr/include/util/delay.h **** 		}
 204:/usr/avr/include/util/delay.h **** 		return;
 205:/usr/avr/include/util/delay.h **** 	}
 206:/usr/avr/include/util/delay.h **** 	else
 207:/usr/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 730               		.loc 2 207 0
 731 02ba C701      		movw r24,r14
 732 02bc B601      		movw r22,r12
 733 02be 0E94 0000 		call __fixunssfsi
 734               	.LVL89:
 735               	.L18:
 736               	.LBB38:
 737               	.LBB39:
 738               		.loc 3 105 0
 739 02c2 CB01      		movw r24,r22
 740               	/* #APP */
 741               	 ;  105 "/usr/avr/include/util/delay_basic.h" 1
 742 02c4 0197      		1: sbiw r24,1
 743 02c6 01F4      		brne 1b
 744               	 ;  0 "" 2
 745               	.LVL90:
 746               	/* #NOAPP */
 747               	.LBE39:
 748               	.LBE38:
 749               	.LBE40:
 750               	.LBE42:
 115:glcd/graphs.c **** 
 751               		.loc 1 115 0
 752 02c8 00C0      		rjmp .L14
 753               	.LVL91:
 754               	.L23:
 755               	.LBB43:
 756               	.LBB41:
 193:/usr/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 757               		.loc 2 193 0
 758 02ca 61E0      		ldi r22,lo8(1)
 759 02cc 70E0      		ldi r23,0
 760 02ce 00C0      		rjmp .L18
 761               	.LBE41:
 762               	.LBE43:
 763               		.cfi_endproc
 764               	.LFE12:
 766               	.Letext0:
 767               		.file 4 "/usr/avr/include/stdint.h"
 768               		.file 5 "glcd/glcd.h"
 769               		.file 6 "glcd/unit_tests.h"
 770               		.file 7 "glcd/glcd_graphics.h"
 771               		.file 8 "glcd/glcd_controllers.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 graphs.c
     /tmp/cc46qeQ5.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/cc46qeQ5.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/cc46qeQ5.s:4      *ABS*:000000000000003f __SREG__
     /tmp/cc46qeQ5.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/cc46qeQ5.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/cc46qeQ5.s:12     .text:0000000000000000 glcd_bar_graph_horizontal
     /tmp/cc46qeQ5.s:102    .text:0000000000000050 glcd_bar_graph_horizontal_no_border
     /tmp/cc46qeQ5.s:152    .text:0000000000000078 glcd_bar_graph_vertical
     /tmp/cc46qeQ5.s:243    .text:00000000000000c8 glcd_bar_graph_vertical_no_border
     /tmp/cc46qeQ5.s:294    .text:00000000000000f0 glcd_scrolling_bar_graph
     /tmp/cc46qeQ5.s:531    .text:00000000000001f6 glcd_scrolling_bar_graph_timing

UNDEFINED SYMBOLS
glcd_draw_rect
__divmodhi4
glcd_fill_rect
glcd_get_pixel
glcd_set_pixel
glcd_draw_line
glcd_write
__floatunsisf
__mulsf3
__ltsf2
__gtsf2
__fixunssfsi
